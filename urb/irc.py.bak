from twisted.application import service, internet
from twisted.words.protocols.irc import IRCClient, DccChat
from twisted.internet import reactor, protocol
import datetime

from twisted.python.log import msg as log, err

from lib import app, db, event
from lib.colors import colorize

class IRCBot(IRCClient):
    nickname = 'TheHost'
    channels = set()
    ignore = set(('NickServ', 'ChanServ'))
    
    # Unicode IO Conversations and colorize
    def sendLine(self, line):
        IRCClient.sendLine(self, str(line))
        
    def dataReceived(self, data):
        try:
            udata = unicode(data)
            ndata = "".join([c for c in udata if ord(c) < 128])
            print "CALLING WITH CLEAN"
            IRCClient.dataReceived(self, ndata)
        except:
            print "CALLING IN EXCEPTION"
            IRCClient.dataReceived(self, data)
            
    # Initialization here
    def connectionMade(self):
        IRCClient.connectionMade(self)
    
    # Perform here
    def signedOn(self):
        # Identify 
        self.msg('Chanserv', 'identify %s %s' % (self.logchannel,
                                                 self.channelpass))
        self.msg('Chanserv', 'identify %s %s' % (self.mainchannel,
                                                 self.channelpass))
        # Join
        self.join(self.mainchannel)
        self.join(self.logchannel)
        self.factory.signed_on = True
        
    def joined(self, channel):
        log('Joined %s' % channel)
        self.channels.add( channel )
            
    def left(self, channel):
        log('Parted %s' % channel)
        if channel in self.channels:
            self.channels.remove(channel)
        
    def privmsg(self, user, channel, message):
        """Called when I have a message from a user to me or a channel.
        """
        # Only actually private messages
        log('PRIVATE MESSAGE: %s, %s, %s' % (user, channel, message))
        user = user.split('!', 1)[0]
        if (channel != self.nickname
            or user in self.ignore
            or not user.strip() or message.startswith('DCC')):
            return
        # Parsing
        parts = message.split()
        command, args = parts[0], parts[1:]
        # Isn't a command
        if command[0] != '.':
            # Introduction
            if app.database.get_user(user): # and not app.is_logged_in(user):
                self.msg(user, 'Please initiate DCC Chat to begin.')
            else:
                self.msg(user, 'Welcome %s, to Ultra Relay Battle!' % user)
                self.msg(user, '    /msg %s .register [email] to register' % (self.nickname))

        # Is a command
        else:
            #Strip prefix
            command = command[1:]
            # Administrative Builtins
            if app.database.is_admin(user):
                if command == 'op':
                    pass
                else:
                    pass # app.public_command(user, command, *args)
            else:
                pass # app.public_command(user, command, *args)
        
    def dccDoChat(self, user, channel, address, port, data):
        log('Dcc Chat Request: %s, %s, %s' % (user, address, port))
        log('Dcc Chat Request Data: %s' % data)
        user = user.split('!', 1)[0]
        self.factory.bind(user, channel, address, port, data)
   
class OurDccChat(DccChat):
    def __init__(self, queryData=None):
        DccChat.__init__(self, None, queryData=queryData)
        
    def connectionMade(self):
        app.bind_session(self.who)

    def lineReceived(self, line):
        log("DCC CHAT<%s> %s" % (self.remoteParty, line))
        parts = line.split()
        command = parts[0]
        args = parts[1:]
        if command[0] == '.':
            app.public_command(self.who, command[1:], *args)
        else:
            self.sendLine("All commands are single words that being with a period.")
            self.sendLine("Maybe try .help if you're unsure.")
    def sendLine(self, line):
        DccChat.sendLine(self, str(line))

class DccChatFactory(protocol.ClientFactory):
    protocol = OurDccChat
    p = None
    noisy = 0
    def __init__(self, factory, queryData):
        self.factory = factory
        self.queryData = queryData

    def buildProtocol(self, addr):
        p = self.protocol(queryData=self.queryData)
        p.factory = self
        p.who = self.queryData[0]
        self.p = p
        return self.p

    def clientConnectionFailed(self, unused_connector, unused_reason):
        log('Dcc Chat connection failed: %s' % (unused_reason.getErrorMessage()))
        self.factory.unbind(self.queryData[0])

    def clientConnectionLost(self, unused_connector, unused_reason):
        log('Dcc Chat connection lost: %s' % (unused_reason.getErrorMessage()))
        self.factory.unbind(self.queryData[0])
        
    def msg(self, message):
        if self.p:
            self.p.sendLine(message)

        
class IRCBotFactory(protocol.ReconnectingClientFactory):
    protocol = IRCBot
    client = None
    signed_on = False
    maxDelay = 15
    
    def __init__(self, ports):
        self.ports = ports
        self.queries = {}
        
    def dataReceived(self, data):
        try:
            protocol.ReconnectingClientFactory.dataReceived(self, data)
        except: 
	        pass
	    
    def buildProtocol(self, addr):
        conf = app.database.get_irc_config()
        client = self.protocol()
        client.factory = self
        client.nickname = conf.nickname
        client.password = conf.nickpass
        client.mainchannel = conf.mainchannel
        client.logchannel = conf.logchannel
        client.channelpass = conf.channelpass
        self.client = client
        return self.client
        
    def stopFactory(self):
        self.signed_on = False
    
    def next_port(self):
        last = self.ports.pop(0)
        self.ports.append(last)
        return self.ports[0]
    
    def clientConnectionFailed(self, connector, reason):
        self.client = None
        connector.port = self.next_port()
        protocol.ReconnectingClientFactory.clientConnectionFailed(self, connector, reason)
    
    # DCC SESSION #
    def bind(self, user, channel, address, port, data):
        u = app.database.get_user(user)
        if u:
            session = DccChatFactory(self, queryData=(user, channel, data))
            reactor.connectTCP(address, port, session)
            self.queries[user] = session
            
    def unbind(self, nickname):
        if nickname in self.queries:
            del self.queries[nickname]
            app.unbind_session(nickname)
            
    # APP EVENT HANDLERS # 
    
    def get_signal_matrix(self):
        return {
            'quit' : self.on_quit,
            'outgoing_msg' : self.on_outgoing_msg
        }
    
    def on_quit(self, reason):
        self.client.quit(message = reason)
        self.stopTrying()
            
    def on_outgoing_msg(self, dest, msg):
        msg = colorize(msg)
        if dest in self.queries:
            self.queries[dest].msg(msg)
        elif dest.startswith('#'):
            self.client.msg(dest, msg)
            

class IRCService(internet.TCPClient):
    service_name = 'irc'

    def __init__(self):
        conf = app.database.get_irc_config()
        network = conf.network
        ports = [int(port) for port in conf.port.split()]
        self.factory = IRCBotFactory(ports)
        internet.TCPClient.__init__(self, network, ports[0], self.factory)
    
    def get_signal_matrix(self):
        return self.factory.get_signal_matrix()
    
    def startService(self):
        self.factory.resetDelay()
        internet.TCPClient.startService(self)

    def stopService(self):
        self.factory.stopTrying()
        internet.TCPClient.stopService(self)
        
    # Informational Methods #
    def is_connected(self):
        return self.factory.signed_on
    
    def channels(self):
        """ Returns a list of currently joined channels """
        p = self.factory.p
        return p.channels
